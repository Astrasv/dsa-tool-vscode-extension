{
    "Python Stack Implementation":{
        "prefix": ":stack",
        "body": [
            "class Stack:",
            "    def __init__(self, capacity: int):",
            "        self.capacity = capacity",
            "        self.items = []",
            "",
            "    def is_empty(self) -> bool:",
            "        return len(self.items) == 0",
            "",
            "    def is_full(self) -> bool:",
            "        return len(self.items) == self.capacity",
            "",
            "    def push(self, item) -> None:",
            "        if self.is_full():",
            "            raise IndexError('push to a full stack')",
            "        else:",
            "            self.items.append(item)",
            "",
            "    def pop(self):",
            "        if not self.is_empty():",
            "            return self.items.pop()",
            "        else:",
            "            raise IndexError('pop from an empty stack')",
            "",
            "    def peek(self):",
            "        if not self.is_empty():",
            "            return self.items[-1]",
            "        else:",
            "            raise IndexError('peek from an empty stack')",
            "",
            "    def size(self) -> int:",
            "        return len(self.items)",
            "",
            "# Sample drive code",
            "if __name__ == '__main__':",
            "    stack = Stack(3)  # Capacity of 3",
            "    stack.push(1)",
            "    stack.push(2)",
            "    stack.push(3)",
            "",
            "    print('Stack:', stack.items)",
            "    print('Size of stack:', stack.size())",
            "    print('Peek:', stack.peek())",
            "",
            "    try:",
            "        stack.push(4)  # Try pushing to a full stack",
            "    except IndexError as e:",
            "        print('Error:', e)",
            "",
            "    popped_item = stack.pop()",
            "    print('Popped item:', popped_item)",
            "",
            "    print('Stack after popping:', stack.items)"
        ],
        "description":  "A class that implements the functionality of a stack data structure."
    },
    "Python Queue Implementation":{
        "prefix": ":queue",
        "body": [
            "from collections import deque",
            "",
            "class Queue:",
            "    def __init__(self):",
            "        self.queue = deque()",
            "",
            "    def is_empty(self) -> bool:",
            "        return len(self.queue) == 0",
            "",
            "    def enqueue(self, item) -> None:",
            "        self.queue.append(item)",
            "",
            "    def dequeue(self):",
            "        if not self.is_empty():",
            "            return self.queue.popleft()",
            "        else:",
            "            raise IndexError('dequeue from an empty queue')",
            "",
            "    def peek(self):",
            "        if not self.is_empty():",
            "            return self.queue[0]",
            "        else:",
            "            raise IndexError('peek from an empty queue')",
            "",
            "    def size(self) -> int:",
            "        return len(self.queue)"
        ],
        "description": "A class that implements the functionality of a queue data structure."
    },
    "Python LinkedList Implementation":{
        "prefix": ":linkedlist",
        "body": [
            "class ListNode:",
            "    def __init__(self, value):",
            "        self.value = value",
            "        self.next = None",
            "",
            "class LinkedList:",
            "    def __init__(self):",
            "        self.head = None",
            "",
            "    def is_empty(self) -> bool:",
            "        return self.head is None",
            "",
            "    def append(self, value) -> None:",
            "        new_node = ListNode(value)",
            "        if not self.head:",
            "            self.head = new_node",
            "        else:",
            "            current = self.head",
            "            while current.next:",
            "                current = current.next",
            "            current.next = new_node",
            "",
            "    def display(self):",
            "        current = self.head",
            "        while current:",
            "            print(current.value, end=' -> ')",
            "            current = current.next",
            "        print('None')"
        ],
        "description": "A class that represents a linked list and provides methods to add elements at the end of the list"
    }
    

}

